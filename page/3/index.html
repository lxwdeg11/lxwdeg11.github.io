<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>莫失莫忘的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="莫失莫忘的博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="莫失莫忘的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="莫失莫忘的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">莫失莫忘的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/10/hello-world3/" class="article-date">
  <time datetime="2022-05-10T02:20:16.618Z" itemprop="datePublished">2022-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/10/hello-world3/">Hello World 3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/10/hello-world3/" data-id="cl2zj0r1s000360vk861u3w27" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hello-World/" rel="tag">Hello World</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-edge-login-issue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/edge-login-issue/" class="article-date">
  <time datetime="2022-05-09T14:38:37.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/edge-login-issue/">登录edge浏览器，报错0x80190001解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>关闭各种代理</p>
</li>
<li><p>设置当前网络的DNS，改用微软的4.2.2.1</p>
<p>重试就可以了，之后记得改回原来的DNS，微软的DNS在访问一些国内网站时不好用</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/edge-login-issue/" data-id="cl2yty06i0000r8vkhb5b79jk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/edge/" rel="tag">edge</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ftp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/ftp/" class="article-date">
  <time datetime="2022-05-09T14:38:37.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/ftp/">登录edge浏览器，报错0x80190001解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ubuntu服务器FTP"><a href="#ubuntu服务器FTP" class="headerlink" title="ubuntu服务器FTP"></a>ubuntu服务器FTP</h1><h6 id="开启FTP服务并重启"><a href="#开启FTP服务并重启" class="headerlink" title="开启FTP服务并重启"></a>开启FTP服务并重启</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service vsftpd restart</span><br></pre></td></tr></table></figure>

<h6 id="查询FTP服务是否存在"><a href="#查询FTP服务是否存在" class="headerlink" title="查询FTP服务是否存在"></a>查询FTP服务是否存在</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ftp</span><br></pre></td></tr></table></figure>

<h6 id="增加用户后"><a href="#增加用户后" class="headerlink" title="增加用户后"></a>增加用户后</h6><p>在<code>/etc/allowed_user</code>文件里增加用户名</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/ftp/" data-id="cl2zj0r1q000260vkasb3d5t9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ftpd/" rel="tag">ftpd</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/hexo/" class="article-date">
  <time datetime="2022-05-09T14:38:37.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/hexo/">登录edge浏览器，报错0x80190001解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="更新和发布新博文："><a href="#更新和发布新博文：" class="headerlink" title="更新和发布新博文："></a>更新和发布新博文：</h1><h2 id="只更新博客"><a href="#只更新博客" class="headerlink" title="只更新博客"></a>只更新博客</h2><p>hexo clean：清空资源文件</p>
<p>hexo g：重新生成资源文件</p>
<p>hexo deploy：发布文章到github.io</p>
<p>最后两部可简写成：hexo g -d</p>
<h2 id="新增post"><a href="#新增post" class="headerlink" title="新增post"></a>新增post</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>

<p><code>D:\myblog\source\_posts</code>下会新增<code>title.md</code>，编辑该md文件，再</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fake_hydra/article/details/82414965">GitHub Pages自定义域名后每次hexo d都会失效解决</a></p>
<p><del>之后每次都需要按照图片中设置一次</del></p>
<p><del><a target="_blank" rel="noopener" href="https://github.com/lxwdeg/lxwdeg.github.io/settings">https://github.com/lxwdeg/lxwdeg.github.io/settings</a></del></p>
<p><del><img src="http://ww1.sinaimg.cn/large/5dc6b88cgy1g8k32957evj20nu0hhgmo.jpg" alt="1572706237345.png"></del></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/hexo/" data-id="cl2zj0r1t000460vkal9t4l9f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo%E7%AE%A1%E7%90%86/" rel="tag">hexo管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/block/" class="article-date">
  <time datetime="2022-05-09T14:37:12.951Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title: block<br>date: 2022-05-09 22:37:12<br>tags:</p>
<ul>
<li>BLOCK IO</li>
<li>LINUX KERNEL</li>
</ul>
<p>[TOC]</p>
<h1 id="block层在内核中结构"><a href="#block层在内核中结构" class="headerlink" title="block层在内核中结构"></a>block层在内核中结构</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526202533888.png" alt="image-20220526202533888"></p>
<h1 id="内存管理与block："><a href="#内存管理与block：" class="headerlink" title="内存管理与block："></a>内存管理与block：</h1><p>用户态page fault</p>
<p>脏页回写</p>
<p>swap out</p>
<p>都会产生IO到block层</p>
<h1 id="cgroups-in-block"><a href="#cgroups-in-block" class="headerlink" title="cgroups in block"></a>cgroups in block</h1><p>三种情况没有支持cgroups：no scheduler, mq-deadline, and kyber  </p>
<h2 id="block-io-cgroup的作用："><a href="#block-io-cgroup的作用：" class="headerlink" title="block io cgroup的作用："></a>block io cgroup的作用：</h2><p>保护高优先级的IO（高优先级负载比低优先级负载优先获得IO）；通过什么方法？</p>
<p>限制cgroup的IOPS；</p>
<p>测量和检测cgroup的IO使用和IO压力（measure and monitor a cgroup’s IO use and <a target="_blank" rel="noopener" href="https://facebookmicrosites.github.io/cgroup2/docs/pressure-metrics.html">IO pressure</a>）</p>
<h2 id="cgroup-V2与V1的对比"><a href="#cgroup-V2与V1的对比" class="headerlink" title="cgroup V2与V1的对比"></a>cgroup V2与V1的对比</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>cgroup V1</td>
<td>只作用于direct IO（文件系统元数据的读写，缓冲读IO），没有控制缓冲写</td>
<td></td>
</tr>
<tr>
<td>cgroup V2</td>
<td>所有IO都能控制：buffered, filesystem metadata, swap, and direct IOs</td>
<td></td>
</tr>
</tbody></table>
<h2 id="cgroup-V2的接口文件"><a href="#cgroup-V2的接口文件" class="headerlink" title="cgroup V2的接口文件"></a>cgroup V2的接口文件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>io.latency</td>
<td>If the average completion latency is longer than the target set here, other processes are throttled to provide more IO, effectively prioritizing the job with the lowest <code>io.latency</code> setting.If the protected workload experiences average completion latency longer than its latency target value, <strong>the controller throttles any peers that have a more relaxed latency target than the protected workload</strong>.  <strong>平均完成时延，统计的时间窗口多大？                                                                                      <strong>The delta between the prioritized cgroup’s target and the targets of other cgroups is used to determine how hard the other cgroups are throttled: If a cgroup with <code>io.latency</code> set to <code>20ms</code> is prioritized, cgroups with latency targets <code>&lt;= 20ms</code> will never be throttled, while a cgroup with <code>50ms</code> will get throttled harder than a cgroup with a <code>30ms</code> target. <strong>这个限制力度是怎么控制的？通过控制cgroup的IO depth？</strong>                            <strong>只有兄弟cgroup才会互相影响。下面的图中，A B C会互相影响，D F会互相影响，G不影响任何其他人。</strong>                                                                                                                       <strong>配置策略</strong>：观察io.stat中你的工作负载的avg_lat的值来确定io.latency数值，比如可以配置1.2倍的io.stat avg_lat。 <code>io.latency</code>是</strong>work conserving</strong>，只有所有的cgroup都满足io.latency，就不会做任何限制。</td>
<td></td>
</tr>
<tr>
<td>io.pressure</td>
<td>这个啥意思？</td>
<td></td>
</tr>
<tr>
<td>io.stat</td>
<td>IO usage statistics.统计<strong>每个块设备</strong>（通过主设备号 次设备号区分）的读、写、擦除三类IO的扇区数和IO个数。</td>
<td></td>
</tr>
<tr>
<td>io.max</td>
<td>IO限制的指标。<strong>每个块设备</strong>分别计算，可以现在读、写IO的最大IOPS或者最大带宽。例如：Setting read limit at 2M BPS and write at 120 IOPS for 8:16：                            echo “8:16 rbps=2097152 wiops=120” &gt; io.max。通过写max取消限制：                 echo “8:16 wiops=max” &gt; io.max</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://facebookmicrosites.github.io/cgroup2/docs/assets/io_latency.png" alt="io latency diagram"></p>
<h2 id="io-latency的数值设置策略，针对ssd和hard-disk分别有设置策略："><a href="#io-latency的数值设置策略，针对ssd和hard-disk分别有设置策略：" class="headerlink" title="io.latency的数值设置策略，针对ssd和hard disk分别有设置策略："></a>io.latency的数值设置策略，针对ssd和hard disk分别有设置策略：</h2><blockquote>
<ol>
<li><strong>Setting <code>io.latency</code> higher (20-25%) than the usual expected latency.</strong> TThis provides a tighter protection guarantee for the workload. However, the tighter control can sometimes mean the system pays more in terms of IO overhead, which leads to lower system-wide IO utilization. A setting like this can be effective for systems with SSDs.</li>
<li><strong>Setting <code>io.latency</code> to several times higher than the usual expected latency, especially for hard disks.</strong> A hard disk’s usual uncontended completion latencies are between 7 and 20ms, but when contention occurs, the completion latency balloons quickly, easily reaching 10 times normal. Because the latency is so volatile, workloads running on hard disks are usually not sensitive to small swings in completion latency; things break down only in extreme conditions when latency jumps several times higher (which isn’t difficult to trigger). Effective protection can be achieved in cases like this by setting a relaxed target on the protected group (e.g., 50 or 75ms), and a higher setting for lower priority groups (e.g., an additional 25ms over the higher priority group). This way, the workload can have reasonable protection without significantly compromising hard disk utilization by triggering throttling when it’s not necessary.</li>
</ol>
</blockquote>
<h2 id="io-latency工作原理，限制的方法（一种是通过限制cgroup的queue-depth，最小限制到一次一个IO，另外一种是Artificial-delay-induction？）："><a href="#io-latency工作原理，限制的方法（一种是通过限制cgroup的queue-depth，最小限制到一次一个IO，另外一种是Artificial-delay-induction？）：" class="headerlink" title="io.latency工作原理，限制的方法（一种是通过限制cgroup的queue depth，最小限制到一次一个IO，另外一种是Artificial delay induction？）："></a>io.latency工作原理，限制的方法（一种是通过限制cgroup的queue depth，最小限制到一次一个IO，另外一种是<strong>Artificial delay induction？</strong>）：</h2><blockquote>
<ul>
<li><strong>Queue depth throttling</strong>—This is the number of outstanding IO’s a group is allowed to have. The controller will clamp down relatively quickly, starting at no limit and going all the way down to 1 IO at a time.</li>
<li><strong>Artificial delay induction</strong>—There are certain types of IO that can’t be throttled without possibly affecting higher priority groups adversely. This includes swapping and metadata IO. These types of IO are allowed to occur normally, but they are “charged” to the originating group.</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://facebookmicrosites.github.io/cgroup2/docs/io-controller.html#fbtax2-io-controller-configuration">IO Controller · cgroup2 (facebookmicrosites.github.io)</a> </p>
<h2 id="这个还没看？"><a href="#这个还没看？" class="headerlink" title="这个还没看？"></a>这个还没看？</h2><h1 id="不同IO-control机制对比："><a href="#不同IO-control机制对比：" class="headerlink" title="不同IO control机制对比："></a>不同IO control机制对比：</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526203239408.png" alt="image-20220526203239408"></p>
<h1 id="bio的cgroup结构："><a href="#bio的cgroup结构：" class="headerlink" title="bio的cgroup结构："></a>bio的cgroup结构：</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">bio结构体中：</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Represents the association of the css and request_queue for the bio.</span></span><br><span class="line"><span class="comment">	 * If a bio goes direct to device, it will not have a blkg as it will</span></span><br><span class="line"><span class="comment">	 * not have a request_queue associated with it.  The reference is put</span></span><br><span class="line"><span class="comment">	 * on release of the bio.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>		*<span class="title">bi_blkg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_issue</span>	<span class="title">bi_issue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP_IOCOST</span></span><br><span class="line">	u64			bi_iocost_cost;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* association between a blk cgroup and a request queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Pointer to the associated request_queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span>		*<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">q_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>		<span class="title">blkcg_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blkcg</span>			*<span class="title">blkcg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* all non-root blkcg_gq&#x27;s are guaranteed to have access to parent */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>			*<span class="title">parent</span>;</span></span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line">bio也可能以root blkg发送：</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bio_issue_as_root_blkg - see if this bio needs to be issued as root blkg</span></span><br><span class="line"><span class="comment"> * @return: true if this bio needs to be submitted with the root blkg context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In order to avoid priority inversions we sometimes need to issue a bio as if</span></span><br><span class="line"><span class="comment"> * it were attached to the root blkg, and then backcharge to the actual owning</span></span><br><span class="line"><span class="comment"> * blkg.  The idea is we do bio_blkcg() to look up the actual context for the</span></span><br><span class="line"><span class="comment"> * bio and attach the appropriate blkg to the bio.  Then we call this helper and</span></span><br><span class="line"><span class="comment"> * if it is true run with the root blkg for that queue and then do any</span></span><br><span class="line"><span class="comment"> * backcharging to the originating cgroup once the io is complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">bio_issue_as_root_blkg</span><span class="params">(<span class="keyword">struct</span> bio *bio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (bio-&gt;bi_opf &amp; (REQ_META | REQ_SWAP)) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="biovecs"><a href="#biovecs" class="headerlink" title="biovecs"></a>biovecs</h1><p>bio提交后biovecs就不能修改了，随着IO完成而修改的是struct bvec_iter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> &#123;</span></span><br><span class="line">	<span class="type">sector_t</span>		bi_sector;	<span class="comment">/* device address in 512 byte</span></span><br><span class="line"><span class="comment">						   sectors */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		bi_size;	<span class="comment">/* residual I/O count */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		bi_idx;		<span class="comment">/* current index into bvl_vec */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>            bi_bvec_done;	<span class="comment">/* number of bytes completed in</span></span><br><span class="line"><span class="comment">						   current bvec */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>驱动代码不应该直接使用biovecs，而应该用bio_iovec() and bio_iter_iovec()</p>
<h3 id="bio-for-each-segment改为需要一个bvec-iter参数，而不是整数参数"><a href="#bio-for-each-segment改为需要一个bvec-iter参数，而不是整数参数" class="headerlink" title="bio_for_each_segment改为需要一个bvec_iter参数，而不是整数参数"></a>bio_for_each_segment改为需要一个bvec_iter参数，而不是整数参数</h3><p>通过bio_advance_iter函数，递增bvec_iter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bio_advance</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">unsigned</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bio_integrity(bio))</span><br><span class="line">		bio_integrity_advance(bio, bytes);</span><br><span class="line"></span><br><span class="line">	bio_advance_iter(bio, &amp;bio-&gt;bi_iter, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个更低层的，bvec_iter_advance，使用biovec指针作为参数，而不是bio指针：</p>
<h3 id="用于block的integrity-code"><a href="#用于block的integrity-code" class="headerlink" title="用于block的integrity code"></a>用于block的integrity code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bio_vec &#123;</span><br><span class="line">	struct page	*bv_page;</span><br><span class="line">	unsigned int	bv_len;//可能跨页面，例如长度是8K</span><br><span class="line">	unsigned int	bv_offset; //可能跨页面，例如offset是4K + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>有一个迭代器，而让真正的biovecs保存不变，有很多好处。</p>
<h3 id="一次迭代一个页："><a href="#一次迭代一个页：" class="headerlink" title="一次迭代一个页："></a>一次迭代一个页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio_for_each_segment()</span><br><span class="line">bio_for_each_segment_all()</span><br></pre></td></tr></table></figure>

<h3 id="一次迭代多个页："><a href="#一次迭代多个页：" class="headerlink" title="一次迭代多个页："></a>一次迭代多个页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bio_for_each_bvec()</span><br><span class="line">bio_for_each_bvec_all()</span><br><span class="line">rq_for_each_bvec()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">introduce <span class="title function_">bio_for_each_bvec</span><span class="params">()</span> to iterate over multipage bvec <span class="keyword">for</span> splitting</span><br><span class="line">	bio and mapping sg</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">introduce bio_for_each_bvec() to iterate over multipage bvec for splitting</span><br><span class="line">	bio and mapping sg</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keep current bio_for_each_segment*() to itereate over singlepage bvec</span><br></pre></td></tr></table></figure>



<h1 id="block层的work"><a href="#block层的work" class="headerlink" title="block层的work"></a>block层的work</h1><h2 id="对应的work-function：blk-mq-run-work-fn"><a href="#对应的work-function：blk-mq-run-work-fn" class="headerlink" title="对应的work function：blk_mq_run_work_fn"></a>对应的work function：blk_mq_run_work_fn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_mq_run_work_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *<span class="title">hctx</span>;</span></span><br><span class="line"></span><br><span class="line">	hctx = container_of(work, <span class="keyword">struct</span> blk_mq_hw_ctx, run_work.work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are stopped, don&#x27;t run the queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blk_mq_hctx_stopped(hctx))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__blk_mq_run_hw_queue(hctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="work初始化"><a href="#work初始化" class="headerlink" title="work初始化"></a>work初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_DELAYED_WORK(&amp;hctx-&gt;run_work, blk_mq_run_work_fn);</span><br></pre></td></tr></table></figure>

<p>每个hctx都有一个自己的run_work，所有这些work，共用一个workqueue：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Controlling structure to kblockd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">kblockd_workqueue</span>;</span></span><br></pre></td></tr></table></figure>

<p><a href="#workqueue%E4%BC%98%E5%8C%96">workqueue优化</a></p>
<h2 id="block的worker运行的cpu："><a href="#block的worker运行的cpu：" class="headerlink" title="block的worker运行的cpu："></a>block的worker运行的cpu：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;d be great if the workqueue API had a way to pass</span></span><br><span class="line"><span class="comment"> * in a mask and had some smarts for more clever placement.</span></span><br><span class="line"><span class="comment"> * For now we just round-robin here, switching for every</span></span><br><span class="line"><span class="comment"> * BLK_MQ_CPU_WORK_BATCH queued items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">blk_mq_hctx_next_cpu</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> tried = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> next_cpu = hctx-&gt;next_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hctx-&gt;<span class="built_in">queue</span>-&gt;nr_hw_queues == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> WORK_CPU_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (--hctx-&gt;next_cpu_batch &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">select_cpu:</span><br><span class="line">		next_cpu = cpumask_next_and(next_cpu, hctx-&gt;cpumask,</span><br><span class="line">				cpu_online_mask);</span><br><span class="line">		<span class="keyword">if</span> (next_cpu &gt;= nr_cpu_ids)</span><br><span class="line">			next_cpu = blk_mq_first_mapped_cpu(hctx);</span><br><span class="line">		hctx-&gt;next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do unbound schedule if we can&#x27;t find a online CPU for this hctx,</span></span><br><span class="line"><span class="comment">	 * and it should only happen in the path of handling CPU DEAD.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_online(next_cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!tried) &#123;</span><br><span class="line">			tried = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">goto</span> select_cpu;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make sure to re-select CPU next time once after CPUs</span></span><br><span class="line"><span class="comment">		 * in hctx-&gt;cpumask become online again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		hctx-&gt;next_cpu = next_cpu;</span><br><span class="line">		hctx-&gt;next_cpu_batch = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> WORK_CPU_UNBOUND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hctx-&gt;next_cpu = next_cpu;</span><br><span class="line">	<span class="keyword">return</span> next_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kblockd_mod_delayed_work_on(blk_mq_hctx_next_cpu(hctx), &amp;hctx-&gt;run_work,</span><br><span class="line">				    msecs_to_jiffies(msecs));</span><br></pre></td></tr></table></figure>

<p>如果queue的硬件队列只有一个，那这个worker运行在WORK_CPU_UNBOUND上，也就是不绑定特定的cpu。</p>
<p>否则，一个cpu上运行<strong>BLK_MQ_CPU_WORK_BATCH</strong>次数后，就换下一个cpu（round robin策略）。</p>
<p>当然，可供选择的cpu的范围：同时在<strong>hctx-&gt;cpumask</strong>和cpu_online_mask里面的cpu。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next_cpu = cpumask_next_and(next_cpu, hctx-&gt;cpumask,</span><br><span class="line">				cpu_online_mask);</span><br></pre></td></tr></table></figure>



<p>hctx-&gt;cpu_mask在blk_mq_map_swqueue函数里面设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpumask_set_cpu(i, hctx-&gt;cpumask)</span><br></pre></td></tr></table></figure>

<h2 id="什么情况运行work？"><a href="#什么情况运行work？" class="headerlink" title="什么情况运行work？"></a>什么情况运行work？</h2><h2 id="什么情况停止work？"><a href="#什么情况停止work？" class="headerlink" title="什么情况停止work？"></a>什么情况停止work？</h2><h1 id="block-passthrough-req流程"><a href="#block-passthrough-req流程" class="headerlink" title="block passthrough req流程"></a>block passthrough req流程</h1><h3 id="end-io流程"><a href="#end-io流程" class="headerlink" title="end_io流程"></a>end_io流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rq-&gt;end_io赋值为了blk_end_sync_rq</span><br><span class="line"></span><br><span class="line"><span class="title function_">DECLARE_COMPLETION_ONSTACK</span><span class="params">(wait)</span>;</span><br><span class="line">rq-&gt;end_io_data = &amp;wait;</span><br><span class="line"></span><br><span class="line">__blk_mq_end_request里面：</span><br><span class="line"><span class="keyword">if</span> (rq-&gt;end_io) &#123;</span><br><span class="line">		rq_qos_done(rq-&gt;q, rq);</span><br><span class="line">		rq-&gt;end_io(rq, error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		blk_mq_free_request(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * blk_end_sync_rq - executes a completion event on a request</span></span><br><span class="line"><span class="comment"> * @rq: request to complete</span></span><br><span class="line"><span class="comment"> * @error: end I/O status of the request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_end_sync_rq</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">blk_status_t</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">waiting</span> =</span> rq-&gt;end_io_data;</span><br><span class="line"></span><br><span class="line">	rq-&gt;end_io_data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * complete last, if this is a stack request the process (and thus</span></span><br><span class="line"><span class="comment">	 * the rq pointer) could be invalid right after this complete()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	complete(waiting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="block层调度器ops"><a href="#block层调度器ops" class="headerlink" title="block层调度器ops"></a>block层调度器ops</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elevator_mq_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*init_sched)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> elevator_type *);</span><br><span class="line">	<span class="type">void</span> (*exit_sched)(<span class="keyword">struct</span> elevator_queue *);</span><br><span class="line">	<span class="type">int</span> (*init_hctx)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*exit_hctx)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*depth_updated)(<span class="keyword">struct</span> blk_mq_hw_ctx *);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> (*allow_merge)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">struct</span> bio *);</span><br><span class="line">	<span class="type">bool</span> (*bio_merge)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> bio *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*request_merge)(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request **, <span class="keyword">struct</span> bio *);</span><br><span class="line">	<span class="type">void</span> (*request_merged)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">enum</span> elv_merge);</span><br><span class="line">	<span class="type">void</span> (*requests_merged)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*limit_depth)(<span class="type">unsigned</span> <span class="type">int</span>, <span class="keyword">struct</span> blk_mq_alloc_data *);</span><br><span class="line">	<span class="type">void</span> (*prepare_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*finish_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*insert_requests)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="keyword">struct</span> list_head *, <span class="type">bool</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">dispatch_request</span>)(<span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *);</span></span><br><span class="line">	<span class="type">bool</span> (*has_work)(<span class="keyword">struct</span> blk_mq_hw_ctx *);</span><br><span class="line">	<span class="type">void</span> (*completed_request)(<span class="keyword">struct</span> request *, u64);</span><br><span class="line">	<span class="type">void</span> (*requeue_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">former_request</span>)(<span class="keyword">struct</span> <span class="title">request_queue</span> *, <span class="keyword">struct</span> <span class="title">request</span> *);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">next_request</span>)(<span class="keyword">struct</span> <span class="title">request_queue</span> *, <span class="keyword">struct</span> <span class="title">request</span> *);</span></span><br><span class="line">	<span class="type">void</span> (*init_icq)(<span class="keyword">struct</span> io_cq *);</span><br><span class="line">	<span class="type">void</span> (*exit_icq)(<span class="keyword">struct</span> io_cq *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);</p>
<p>bio转化为request之前，尝试与现有的request合并。</p>
<p>int (*request_merge)(struct request_queue *q, struct request **, struct bio *);</p>
<p>把BIO合并到现有的request中，如果合并成功，则把request指针存到struct request **中。</p>
<p>void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);</p>
<p>上面BIO合并到一个request后，如果这个新的request可能跟前面或者后面的request可以合并（见attempt_front_merge和attempt_back_merge），则合并后的处理函数为  request_merged。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct request *attempt_back_merge(struct request_queue *q,</span><br><span class="line">		struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request *next = elv_latter_request(q, rq);</span><br><span class="line"></span><br><span class="line">	if (next)</span><br><span class="line">		return attempt_merge(q, rq, next);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct request *attempt_front_merge(struct request_queue *q,</span><br><span class="line">		struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request *prev = elv_former_request(q, rq);</span><br><span class="line"></span><br><span class="line">	if (prev)</span><br><span class="line">		return attempt_merge(q, prev, rq);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>void (*requests_merged)(struct request_queue *, struct request *, struct request *);</p>
<p>request插入到调度器队列里面时，尝试遍历队列里request，找到能合并的request。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Callback function that is invoked after @next has been merged into @req.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dd_merged_requests</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request *req,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> request *next)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例子一：</span><br><span class="line">   dd_insert_request</span><br><span class="line">	blk_mq_sched_try_insert_merge</span><br><span class="line">		elv_attempt_insert_merge</span><br><span class="line">			blk_attempt_req_merge</span><br><span class="line">				attempt_merge</span><br><span class="line">					elv_merge_requests</span><br><span class="line">例子二：</span><br><span class="line">  dd_bio_merge</span><br><span class="line">    blk_mq_sched_try_merge</span><br><span class="line">    	elv_merge后可能bio_attempt_back_merge后可能二次合并attempt_back_merge</span><br><span class="line">    		attempt_merge</span><br><span class="line">    			elv_merge_requests</span><br><span class="line"><span class="type">void</span> <span class="title function_">elv_merge_requests</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request *rq,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> request *next)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">e</span> =</span> q-&gt;elevator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;type-&gt;ops.requests_merged)</span><br><span class="line">		e-&gt;type-&gt;ops.requests_merged(q, rq, next);</span><br><span class="line"></span><br><span class="line">	elv_rqhash_reposition(q, rq);</span><br><span class="line">	q-&gt;last_merge = rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以合并，则作用是：next合并到req后，调度器需要做的处理；</p>
<p>void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);</p>
<p>调用地方：</p>
<p>static struct request *__blk_mq_alloc_request(struct blk_mq_alloc_data *data)里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Flush/passthrough requests are special and go directly to the</span></span><br><span class="line"><span class="comment">		 * dispatch list. Don&#x27;t include reserved tags in the</span></span><br><span class="line"><span class="comment">		 * limiting, as it isn&#x27;t useful.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!op_is_flush(data-&gt;cmd_flags) &amp;&amp;</span><br><span class="line">		    !blk_op_is_passthrough(data-&gt;cmd_flags) &amp;&amp;</span><br><span class="line">		    e-&gt;type-&gt;ops.limit_depth &amp;&amp;</span><br><span class="line">		    !(data-&gt;flags &amp; BLK_MQ_REQ_RESERVED))</span><br><span class="line">			e-&gt;type-&gt;ops.limit_depth(data-&gt;cmd_flags, data);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>limit_depth函数里面会设置data-&gt;shallow_depth，req获取tag时候会根据data-&gt;shallow_depth限制深度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __blk_mq_get_tag(<span class="keyword">struct</span> blk_mq_alloc_data *data,</span><br><span class="line">			    <span class="keyword">struct</span> sbitmap_queue *bt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!data-&gt;q-&gt;elevator &amp;&amp; !(data-&gt;flags &amp; BLK_MQ_REQ_RESERVED) &amp;&amp;</span><br><span class="line">			!hctx_may_queue(data-&gt;hctx, bt))</span><br><span class="line">		<span class="keyword">return</span> BLK_MQ_NO_TAG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;shallow_depth)</span><br><span class="line">		<span class="keyword">return</span> __sbitmap_queue_get_shallow(bt, data-&gt;shallow_depth);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> __sbitmap_queue_get(bt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">blk_mq_sched_try_merge</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> nr_segs, <span class="keyword">struct</span> request **merged_request)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (elv_merge(q, &amp;rq, bio)) &#123;<span class="comment">//queue里找到bio能合并到的rq，从e-&gt;hash哈希表（或者q-&gt;last_merge）里选择rq，或者通过e-&gt;type-&gt;ops.request_merge选择bio能合并到的req</span></span><br><span class="line">    <span class="comment">//e-&gt;hash是以req的结束扇区地址为哈希值     </span></span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_BACK_MERGE:</span><br><span class="line">		<span class="keyword">if</span> (!blk_mq_sched_allow_merge(q, rq, bio))<span class="comment">//是否允许合并</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (bio_attempt_back_merge(rq, bio, nr_segs) != BIO_MERGE_OK)<span class="comment">//执行bio合并到rq动作</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		*merged_request = attempt_back_merge(q, rq);<span class="comment">//bio合并到rq后，rq尝试与后面的一个请求rq合并，attempt_back_merge调用attempt_merge</span></span><br><span class="line">		<span class="keyword">if</span> (!*merged_request)</span><br><span class="line">			elv_merged_request(q, rq, ELEVATOR_BACK_MERGE);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_FRONT_MERGE:</span><br><span class="line">		<span class="keyword">if</span> (!blk_mq_sched_allow_merge(q, rq, bio))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (bio_attempt_front_merge(rq, bio, nr_segs) != BIO_MERGE_OK)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		*merged_request = attempt_front_merge(q, rq);<span class="comment">//attempt_front_merge调用attempt_merge</span></span><br><span class="line">		<span class="keyword">if</span> (!*merged_request)</span><br><span class="line">			elv_merged_request(q, rq, ELEVATOR_FRONT_MERGE);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_DISCARD_MERGE:</span><br><span class="line">		<span class="keyword">return</span> bio_attempt_discard_merge(q, rq, bio) == BIO_MERGE_OK;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ops.prepare_request:</p>
<p>调用位置：req初始化时候调用e-&gt;type-&gt;ops.prepare_request(rq);（条件if (e &amp;&amp; e-&gt;type-&gt;ops.prepare_request)）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static struct request *blk_mq_rq_ctx_init(struct blk_mq_alloc_data *data,</span><br><span class="line">		unsigned int tag, u64 alloc_time_ns)：</span><br><span class="line">		</span><br><span class="line">if (!op_is_flush(data-&gt;cmd_flags)) &#123;</span><br><span class="line">		struct elevator_queue *e = data-&gt;q-&gt;elevator;</span><br><span class="line"></span><br><span class="line">		rq-&gt;elv.icq = NULL;</span><br><span class="line">		if (e &amp;&amp; e-&gt;type-&gt;ops.prepare_request) &#123;</span><br><span class="line">			if (e-&gt;type-&gt;icq_cache)</span><br><span class="line">				blk_mq_sched_assign_ioc(rq);</span><br><span class="line"></span><br><span class="line">			e-&gt;type-&gt;ops.prepare_request(rq);</span><br><span class="line">			rq-&gt;rq_flags |= RQF_ELVPRIV;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ops.finish_request调用位置：</p>
<p>req free时候调用ops.finish_request。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void blk_mq_free_request(struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request_queue *q = rq-&gt;q;</span><br><span class="line">	struct elevator_queue *e = q-&gt;elevator;</span><br><span class="line">	struct blk_mq_ctx *ctx = rq-&gt;mq_ctx;</span><br><span class="line">	struct blk_mq_hw_ctx *hctx = rq-&gt;mq_hctx;</span><br><span class="line"></span><br><span class="line">	if (rq-&gt;rq_flags &amp; RQF_ELVPRIV) &#123;</span><br><span class="line">		if (e &amp;&amp; e-&gt;type-&gt;ops.finish_request)</span><br><span class="line">			e-&gt;type-&gt;ops.finish_request(rq);</span><br><span class="line">		if (rq-&gt;elv.icq) &#123;</span><br><span class="line">			put_io_context(rq-&gt;elv.icq-&gt;ioc);</span><br><span class="line">			rq-&gt;elv.icq = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;rq_completed[rq_is_sync(rq)]++;</span><br><span class="line">	if (rq-&gt;rq_flags &amp; RQF_MQ_INFLIGHT)</span><br><span class="line">		__blk_mq_dec_active_requests(hctx);</span><br><span class="line"></span><br><span class="line">	if (unlikely(laptop_mode &amp;&amp; !blk_rq_is_passthrough(rq)))</span><br><span class="line">		laptop_io_completion(q-&gt;disk-&gt;bdi);</span><br><span class="line"></span><br><span class="line">	rq_qos_done(q, rq);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(rq-&gt;state, MQ_RQ_IDLE);</span><br><span class="line">	if (refcount_dec_and_test(&amp;rq-&gt;ref))</span><br><span class="line">		__blk_mq_free_request(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">static void dd_finish_request(struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request_queue *q = rq-&gt;q;</span><br><span class="line">	struct deadline_data *dd = q-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	const u8 ioprio_class = dd_rq_ioclass(rq);</span><br><span class="line">	const enum dd_prio prio = ioprio_class_to_prio[ioprio_class];</span><br><span class="line">	struct dd_per_prio *per_prio = &amp;dd-&gt;per_prio[prio];</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The block layer core may call dd_finish_request() without having</span><br><span class="line">	 * called dd_insert_requests(). Hence only update statistics for</span><br><span class="line">	 * requests for which dd_insert_requests() has been called. See also</span><br><span class="line">	 * blk_mq_request_bypass_insert().</span><br><span class="line">	 */</span><br><span class="line">	if (rq-&gt;elv.priv[0])</span><br><span class="line">		dd_count(dd, completed, prio);</span><br><span class="line"></span><br><span class="line">	if (blk_queue_is_zoned(q)) &#123;</span><br><span class="line">		unsigned long flags;</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;dd-&gt;zone_lock, flags);</span><br><span class="line">		blk_req_zone_write_unlock(rq);</span><br><span class="line">		if (!list_empty(&amp;per_prio-&gt;fifo_list[DD_WRITE]))</span><br><span class="line">			blk_mq_sched_mark_restart_hctx(rq-&gt;mq_hctx);</span><br><span class="line">		spin_unlock_irqrestore(&amp;dd-&gt;zone_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ops的void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_mq_sched_insert_request</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">bool</span> at_head,</span></span><br><span class="line"><span class="params">				 <span class="type">bool</span> run_queue, <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> rq-&gt;q;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">e</span> =</span> q-&gt;elevator;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ctx</span> *<span class="title">ctx</span> =</span> rq-&gt;mq_ctx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *<span class="title">hctx</span> =</span> rq-&gt;mq_hctx;</span><br><span class="line"></span><br><span class="line">	WARN_ON(e &amp;&amp; (rq-&gt;tag != BLK_MQ_NO_TAG));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blk_mq_sched_bypass_insert(hctx, rq)) &#123;<span class="comment">//如果rq_flags带RQF_FLUSH_SEQ标记，或者是passthrough请求，则rq直接插入hctx-&gt;dispatch链表</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Firstly normal IO request is inserted to scheduler queue or</span></span><br><span class="line"><span class="comment">		 * sw queue, meantime we add flush request to dispatch queue(</span></span><br><span class="line"><span class="comment">		 * hctx-&gt;dispatch) directly and there is at most one in-flight</span></span><br><span class="line"><span class="comment">		 * flush request for each hw queue, so it doesn&#x27;t matter to add</span></span><br><span class="line"><span class="comment">		 * flush request to tail or front of the dispatch queue.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Secondly in case of NCQ, flush request belongs to non-NCQ</span></span><br><span class="line"><span class="comment">		 * command, and queueing it will fail when there is any</span></span><br><span class="line"><span class="comment">		 * in-flight normal IO request(NCQ command). When adding flush</span></span><br><span class="line"><span class="comment">		 * rq to the front of hctx-&gt;dispatch, it is easier to introduce</span></span><br><span class="line"><span class="comment">		 * extra time to flush rq&#x27;s latency because of S_SCHED_RESTART</span></span><br><span class="line"><span class="comment">		 * compared with adding to the tail of dispatch queue, then</span></span><br><span class="line"><span class="comment">		 * chance of flush merge is increased, and less flush requests</span></span><br><span class="line"><span class="comment">		 * will be issued to controller. It is observed that ~10% time</span></span><br><span class="line"><span class="comment">		 * is saved in blktests block/004 on disk attached to AHCI/NCQ</span></span><br><span class="line"><span class="comment">		 * drive when adding flush rq to the front of hctx-&gt;dispatch.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Simply queue flush rq to the front of hctx-&gt;dispatch so that</span></span><br><span class="line"><span class="comment">		 * intensive flush workloads can benefit in case of NCQ HW.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		at_head = (rq-&gt;rq_flags &amp; RQF_FLUSH_SEQ) ? <span class="literal">true</span> : at_head;</span><br><span class="line">		blk_mq_request_bypass_insert(rq, at_head, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">goto</span> run;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e) &#123;<span class="comment">//如果有调度器，则调调度器的e-&gt;type-&gt;ops.insert_requests</span></span><br><span class="line">		LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		list_add(&amp;rq-&gt;queuelist, &amp;<span class="built_in">list</span>);</span><br><span class="line">		e-&gt;type-&gt;ops.insert_requests(hctx, &amp;<span class="built_in">list</span>, at_head);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//没有调度器，插入ctx-&gt;rq_lists[hctx-&gt;type]链表</span></span><br><span class="line">		spin_lock(&amp;ctx-&gt;lock);</span><br><span class="line">		__blk_mq_insert_request(hctx, rq, at_head);</span><br><span class="line">		spin_unlock(&amp;ctx-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">run:</span><br><span class="line">	<span class="keyword">if</span> (run_queue)</span><br><span class="line">		blk_mq_run_hw_queue(hctx, async);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ops的dispatch_request:</p>
<p>IO下发时，先下发hctx-&gt;dispatch链表里的，再根据是否定义调度器类型，决定是从调度器中取IO（即是ops的dispatch_request）还是ctx-&gt;rq_lists中取IO下发。</p>
<p>ops的has_work：</p>
<p>bool (*has_work)(struct blk_mq_hw_ctx *);</p>
<p>调度器的某个hctx，是否有待处理的req。</p>
<p>ops.completed_request：</p>
<p>__blk_mq_end_request里面调用blk_mq_sched_completed_request(rq, now);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">blk_mq_sched_completed_request</span><span class="params">(<span class="keyword">struct</span> request *rq, u64 now)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">e</span> =</span> rq-&gt;q-&gt;elevator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e &amp;&amp; e-&gt;type-&gt;ops.completed_request)</span><br><span class="line">		e-&gt;type-&gt;ops.completed_request(rq, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __blk_mq_end_request(<span class="keyword">struct</span> request *rq, <span class="type">blk_status_t</span> error)</span><br><span class="line">&#123;</span><br><span class="line">	u64 now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blk_mq_need_time_stamp(rq))</span><br><span class="line">		now = ktime_get_ns();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rq_flags &amp; RQF_STATS) &#123;</span><br><span class="line">		blk_mq_poll_stats_start(rq-&gt;q);</span><br><span class="line">		blk_stat_add(rq, now);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blk_mq_sched_completed_request(rq, now);</span><br><span class="line"></span><br><span class="line">	blk_account_io_done(rq, now);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;end_io) &#123;</span><br><span class="line">		rq_qos_done(rq-&gt;q, rq);</span><br><span class="line">		rq-&gt;end_io(rq, error);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		blk_mq_free_request(rq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于kyber调度器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_completed_request</span><span class="params">(<span class="keyword">struct</span> request *rq, u64 now)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> rq-&gt;q-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_cpu_latency</span> *<span class="title">cpu_latency</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain;</span><br><span class="line">	u64 target;</span><br><span class="line"></span><br><span class="line">	sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);</span><br><span class="line">	<span class="keyword">if</span> (sched_domain == KYBER_OTHER)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	cpu_latency = get_cpu_ptr(kqd-&gt;cpu_latency);</span><br><span class="line">	target = kqd-&gt;latency_targets[sched_domain];</span><br><span class="line">	add_latency_sample(cpu_latency, sched_domain, KYBER_TOTAL_LATENCY,</span><br><span class="line">			   target, now - rq-&gt;start_time_ns);</span><br><span class="line">	add_latency_sample(cpu_latency, sched_domain, KYBER_IO_LATENCY, target,</span><br><span class="line">			   now - rq-&gt;io_start_time_ns);</span><br><span class="line">	put_cpu_ptr(kqd-&gt;cpu_latency);</span><br><span class="line"></span><br><span class="line">	timer_reduce(&amp;kqd-&gt;timer, jiffies + HZ / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ops.requeue_request：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">blk_mq_sched_requeue_request</span><span class="params">(<span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> rq-&gt;q;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">e</span> =</span> q-&gt;elevator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((rq-&gt;rq_flags &amp; RQF_ELVPRIV) &amp;&amp; e &amp;&amp; e-&gt;type-&gt;ops.requeue_request)</span><br><span class="line">		e-&gt;type-&gt;ops.requeue_request(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ops的struct request *(*former_request)(struct request_queue *, struct request *)：</p>
<p>bfq-iosched.c:7279:             .former_request         = elv_rb_former_request,</p>
<p>mq-deadline.c:1069:             .former_request         = elv_rb_former_request,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> request *<span class="title function_">elv_rb_former_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbprev</span> =</span> rb_prev(&amp;rq-&gt;rb_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rbprev)</span><br><span class="line">		<span class="keyword">return</span> rb_entry_rq(rbprev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ops的struct request *(*next_request)(struct request_queue *, struct request *)：</p>
<p>bfq-iosched.c:7278:             .next_request           = elv_rb_latter_request,</p>
<p>mq-deadline.c:1068:             .next_request           = elv_rb_latter_request,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> request *<span class="title function_">elv_rb_latter_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbnext</span> =</span> rb_next(&amp;rq-&gt;rb_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rbnext)</span><br><span class="line">		<span class="keyword">return</span> rb_entry_rq(rbnext);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ops的init-icq与exit-icq？"><a href="#ops的init-icq与exit-icq？" class="headerlink" title="ops的init_icq与exit_icq？"></a>ops的init_icq与exit_icq？</h1><h2 id="bio-merge与request-merge区别？"><a href="#bio-merge与request-merge区别？" class="headerlink" title="bio_merge与request_merge区别？"></a>bio_merge与request_merge区别？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_type</span> *<span class="title">type</span>;</span></span><br><span class="line">	<span class="type">void</span> *elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">sysfs_lock</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> registered:<span class="number">1</span>;</span><br><span class="line">	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>elevator_queue的hash：</p>
<p>请求加入hash队列时候是以请求的结束地址加入的。</p>
<h3 id="BLK-MQ-REQ-PM"><a href="#BLK-MQ-REQ-PM" class="headerlink" title="BLK_MQ_REQ_PM"></a>BLK_MQ_REQ_PM</h3><p>调用地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">blk_queue_enter被调用：</span><br><span class="line">    bio_queue_enter： <span class="keyword">while</span> (!blk_try_enter_queue(q, <span class="literal">false</span>)) &#123;<span class="comment">//从文件系统下发的IO都走这</span></span><br><span class="line">    blk_queue_enter： <span class="keyword">while</span> (!blk_try_enter_queue(q, pm)) &#123;<span class="comment">//非文件系统下发的IO走这；比如scsi_execute</span></span><br><span class="line">        </span><br><span class="line">   __scsi_execute -&gt; blk_get_request -&gt; blk_mq_alloc_request -&gt; blk_queue_enter</span><br><span class="line">       </span><br><span class="line"><span class="type">int</span> __scsi_execute(<span class="keyword">struct</span> scsi_device *sdev, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cmd,</span><br><span class="line">		 <span class="type">int</span> data_direction, <span class="type">void</span> *buffer, <span class="type">unsigned</span> bufflen,</span><br><span class="line">		 <span class="type">unsigned</span> <span class="type">char</span> *sense, <span class="keyword">struct</span> scsi_sense_hdr *sshdr,</span><br><span class="line">		 <span class="type">int</span> timeout, <span class="type">int</span> retries, u64 flags, <span class="type">req_flags_t</span> rq_flags,</span><br><span class="line">		 <span class="type">int</span> *resid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scsi_request</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	req = blk_get_request(sdev-&gt;request_queue,</span><br><span class="line">			data_direction == DMA_TO_DEVICE ?</span><br><span class="line">			REQ_OP_DRV_OUT : REQ_OP_DRV_IN,</span><br><span class="line">			rq_flags &amp; RQF_PM ? BLK_MQ_REQ_PM : <span class="number">0</span>);</span><br><span class="line">       <span class="comment">/*rq_flags如果带RQF_PM，则blk_mq_alloc_data的flags就会带上BLK_MQ_REQ_PM</span></span><br><span class="line"><span class="comment">       比如sd_start_stop_device：res = scsi_execute(sdp, cmd, DMA_NONE, NULL, 0, NULL, &amp;sshdr, SD_TIMEOUT, sdkp-&gt;max_retries, 0, RQF_PM, NULL);</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">       ......</span><br><span class="line">           </span><br><span class="line"><span class="type">int</span> <span class="title function_">blk_queue_enter</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="type">blk_mq_req_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> pm = flags &amp; BLK_MQ_REQ_PM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!blk_try_enter_queue(q, pm)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; BLK_MQ_REQ_NOWAIT)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * read pair of barrier in blk_freeze_queue_start(), we need to</span></span><br><span class="line"><span class="comment">		 * order reading __PERCPU_REF_DEAD flag of .q_usage_counter and</span></span><br><span class="line"><span class="comment">		 * reading .mq_freeze_depth or queue dying flag, otherwise the</span></span><br><span class="line"><span class="comment">		 * following wait may never return if the two reads are</span></span><br><span class="line"><span class="comment">		 * reordered.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		smp_rmb();</span><br><span class="line">		wait_event(q-&gt;mq_freeze_wq,</span><br><span class="line">			   (!q-&gt;mq_freeze_depth &amp;&amp;</span><br><span class="line">			    blk_pm_resume_queue(pm, q)) ||</span><br><span class="line">			   blk_queue_dying(q));</span><br><span class="line">		<span class="keyword">if</span> (blk_queue_dying(q))</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">blk_try_enter_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="type">bool</span> pm)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (!percpu_ref_tryget_live(&amp;q-&gt;q_usage_counter))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The code that increments the pm_only counter must ensure that the</span></span><br><span class="line"><span class="comment">	 * counter is globally visible before the queue is unfrozen.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blk_queue_pm_only(q) &amp;&amp;</span><br><span class="line">	    (!pm || queue_rpm_status(q) == RPM_SUSPENDED))</span><br><span class="line">		<span class="keyword">goto</span> fail_put;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">fail_put:</span><br><span class="line">	percpu_ref_put(&amp;q-&gt;q_usage_counter);</span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_queue_pm_only(q)	atomic_read(&amp;(q)-&gt;pm_only)</span></span><br><span class="line">request_queue的pm_only字段：</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of contexts that have called blk_set_pm_only(). If this</span></span><br><span class="line"><span class="comment">	 * counter is above zero then only RQF_PM requests are processed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		pm_only;   </span><br></pre></td></tr></table></figure>

<p>scsi_device_quiesce - Block all commands except power management.</p>
<p>@sdev:    scsi device to quiesce.</p>
<p>scsi_device_quiesce： blk_set_pm_only(q);<br>ufshcd_wl_shutdown会调用scsi_device_quiesce(sdev);<br>scsi_dev_type_suspend -&gt; scsi_device_quiesce(sdev);</p>
<h2 id="blk-freeze-queue："><a href="#blk-freeze-queue：" class="headerlink" title="blk_freeze_queue："></a>blk_freeze_queue：</h2><p>blk_freeze_queue目的</p>
<ul>
<li><p>Guarantee no request is in use, so we can change any data structure of the queue afterward.</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_freeze_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In the !blk_mq case we are only calling this to kill the</span></span><br><span class="line"><span class="comment">	 * q_usage_counter, otherwise this increases the freeze depth</span></span><br><span class="line"><span class="comment">	 * and waits for it to return to zero.  For this reason there is</span></span><br><span class="line"><span class="comment">	 * no blk_unfreeze_queue(), and blk_freeze_queue() is not</span></span><br><span class="line"><span class="comment">	 * exported to drivers as the only user for unfreeze is blk_mq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	blk_freeze_queue_start(q);<span class="comment">//把percpu_ref的q_usage_counter kill掉，防止后来的请求进入block层，如果是mq，则同步run q，把已经有的请求都排空</span></span><br><span class="line">	blk_mq_freeze_queue_wait(q);<span class="comment">//等待q-&gt;q_usage_counter为0，即所有req都完成了即q_usage_counter计数减到了0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_freeze_queue_start</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;q-&gt;mq_freeze_lock);</span><br><span class="line">	<span class="keyword">if</span> (++q-&gt;mq_freeze_depth == <span class="number">1</span>) &#123;</span><br><span class="line">		percpu_ref_kill(&amp;q-&gt;q_usage_counter);</span><br><span class="line">		mutex_unlock(&amp;q-&gt;mq_freeze_lock);</span><br><span class="line">		<span class="keyword">if</span> (queue_is_mq(q))</span><br><span class="line">			blk_mq_run_hw_queues(q, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mutex_unlock(&amp;q-&gt;mq_freeze_lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_mq_freeze_queue_wait</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	wait_event(q-&gt;mq_freeze_wq, percpu_ref_is_zero(&amp;q-&gt;q_usage_counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="blk-mq-sched-restart？"><a href="#blk-mq-sched-restart？" class="headerlink" title="blk_mq_sched_restart？"></a>blk_mq_sched_restart？</h2><h2 id="bio-gt-bi-opf-的REQ-META与REQ-SWAP？bio-gt-bi-blkg-bio-issue-as-root-blkg？"><a href="#bio-gt-bi-opf-的REQ-META与REQ-SWAP？bio-gt-bi-blkg-bio-issue-as-root-blkg？" class="headerlink" title="bio-&gt;bi_opf 的REQ_META与REQ_SWAP？bio-&gt;bi_blkg?bio_issue_as_root_blkg？"></a>bio-&gt;bi_opf 的REQ_META与REQ_SWAP？bio-&gt;bi_blkg?bio_issue_as_root_blkg？</h2><h1 id="index-ida-alloc-amp-sd-index-ida-GFP-KERNEL"><a href="#index-ida-alloc-amp-sd-index-ida-GFP-KERNEL" class="headerlink" title="index = ida_alloc(&amp;sd_index_ida, GFP_KERNEL);?"></a>index = ida_alloc(&amp;sd_index_ida, GFP_KERNEL);?</h1><h1 id="scsi层的suspend-resume？"><a href="#scsi层的suspend-resume？" class="headerlink" title="scsi层的suspend resume？"></a>scsi层的suspend resume？</h1><h1 id="FLUSH请求"><a href="#FLUSH请求" class="headerlink" title="FLUSH请求"></a>FLUSH请求</h1><h2 id="如何标识flush请求？"><a href="#如何标识flush请求？" class="headerlink" title="如何标识flush请求？"></a>如何标识flush请求？</h2><p>rq_flags带RQF_FLUSH_SEQ标记？</p>
<p>OP的种类：REQ_FUA  REQ_PREFLUSH区别？</p>
<h2 id="flush请求插入队列？"><a href="#flush请求插入队列？" class="headerlink" title="flush请求插入队列？"></a>flush请求插入队列？</h2><h1 id="看flush结构体怎么用？"><a href="#看flush结构体怎么用？" class="headerlink" title="看flush结构体怎么用？"></a>看flush结构体怎么用？</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220618121725568.png" alt="image-20220618121725568"></p>
<h1 id="ioc-是啥？"><a href="#ioc-是啥？" class="headerlink" title="ioc 是啥？"></a>ioc 是啥？</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220618121746874.png" alt="image-20220618121746874"></p>
<h1 id="request可能加入三个位置："><a href="#request可能加入三个位置：" class="headerlink" title="request可能加入三个位置："></a>request可能加入三个位置：</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220614230133242.png" alt="image-20220614230133242"></p>
<p><strong>哈希表，链表，红黑树</strong></p>
<h1 id="看看bio合并，req合并的条件？"><a href="#看看bio合并，req合并的条件？" class="headerlink" title="看看bio合并，req合并的条件？"></a>看看bio合并，req合并的条件？</h1><h1 id="哪些种类IO有rq-gt-end-io指针？"><a href="#哪些种类IO有rq-gt-end-io指针？" class="headerlink" title="哪些种类IO有rq-&gt;end_io指针？"></a>哪些种类IO有rq-&gt;end_io指针？</h1><h1 id="可能优化点："><a href="#可能优化点：" class="headerlink" title="可能优化点："></a>可能优化点：</h1><h2 id="workqueue优化"><a href="#workqueue优化" class="headerlink" title="workqueue优化"></a>workqueue优化</h2><h3 id="采用多个workqueue"><a href="#采用多个workqueue" class="headerlink" title="采用多个workqueue"></a>采用多个workqueue</h3><h4 id="不同优先级的IO，采用不同优先级的workqueue？"><a href="#不同优先级的IO，采用不同优先级的workqueue？" class="headerlink" title="不同优先级的IO，采用不同优先级的workqueue？"></a>不同优先级的IO，采用不同优先级的workqueue？</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/block/" data-id="cl2yty06q0001r8vkaenx88u6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/test/" class="article-date">
  <time datetime="2022-05-09T14:21:50.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/test/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我测试一下</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/test/" data-id="cl2ytc1fw00000kvkaw4rdkf0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for-test/" rel="tag">for test</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/hello-world-1/" class="article-date">
  <time datetime="2022-05-09T14:08:43.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/hello-world-1/">hello_world</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hello Word</p>
<p>2022-05-09</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/hello-world-1/" data-id="cl2ysvow50000rgvk6mlwdgd1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hello-World/" rel="tag">Hello World</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/hello-world/" class="article-date">
  <time datetime="2022-05-09T14:02:40.385Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/hello-world/" data-id="cl2ysvowf0001rgvk4bmz81ca" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hello-World/" rel="tag">Hello World</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-安卓虚拟机Dalvik和ART" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/16/%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BADalvik%E5%92%8CART/" class="article-date">
  <time datetime="2021-09-16T13:16:59.426Z" itemprop="datePublished">2021-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安卓堆栈："><a href="#安卓堆栈：" class="headerlink" title="安卓堆栈："></a>安卓堆栈：</h2><p><img src="https://source.android.com/images/android_framework_details.png" alt="Android 框架详情"></p>
<h2 id="虚拟机Dalvik和ART"><a href="#虚拟机Dalvik和ART" class="headerlink" title="虚拟机Dalvik和ART"></a>虚拟机Dalvik和ART</h2><p>众所周知，Android系统是以Linux为内核构建的。Google为了降低应用的开发难度，并将其适配到不同硬件配置的设备上，在Linux内核之上构建了一个虚拟机，Android应用使用java开发，运行在虚拟机之上。</p>
<p>Dalvik就是Android4.4及之前使用的虚拟机，它使用的是JIT（Just-In-Time）技术来进行代码转译，每次执行应用的时候，Dalvik将程序的代码编译为机器语言执行。随着硬件水平的不断发展以及人们对更高性能的需求，Dalvik虚拟机的不足日益突出。而应运而生的ART(Android RunTime)虚拟机，其处理机制根本上的区别是：它采用AOT(Ahead-Of-Time)技术，会在应用程序安装时就转换成机器语言，不再在执行时解释，从而优化了应用运行的速度。在内存管理方面，ART也有比较大的改进，对内存分配和回收都做了算法优化，降低了内存碎片化程度，回收时间也得以缩短。</p>
<p>Dalvik是应用执行的时候翻译为机器语言。</p>
<p>ART是应用安装时候翻译为机器语言。</p>
<h2 id="apk运行过程"><a href="#apk运行过程" class="headerlink" title="apk运行过程"></a>apk运行过程</h2><p><img src="D:\appdata\Roaming\Typora\typora-user-images\image-20210916214253504.png" alt="image-20210916214253504"></p>
<p>ART虚拟机会把应用弄成ELF可执行文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/16/%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BADalvik%E5%92%8CART/" data-id="cl3mi7je200009cvkh5ae9rpd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="modulenotfounderror:-contextlib" class="article article-type-modulenotfounderror:" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/26/contextlib/" class="article-date">
  <time datetime="2020-02-26T15:32:45.000Z" itemprop="datePublished">2020-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/26/contextlib/">&#39;contextlib&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pycharm新建一个PY文件运行报错：</p>
<h1 id="ModuleNotFoundError-No-module-named-‘contextlib’"><a href="#ModuleNotFoundError-No-module-named-‘contextlib’" class="headerlink" title="ModuleNotFoundError: No module named ‘contextlib’"></a>ModuleNotFoundError: No module named ‘contextlib’</h1><p>解决方法：</p>
<p>使用pycharm新建一个虚拟环境！在新的虚拟环境里就OK了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/26/contextlib/" data-id="cl2zj0r1m000160vk7bg5f0fw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/">安卓开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arm64/" rel="tag">Arm64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Busybox/" rel="tag">Busybox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hello-World/" rel="tag">Hello World</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage/" rel="tag">Storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/" rel="tag">adb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edge/" rel="tag">edge</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for-test/" rel="tag">for test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftpd/" rel="tag">ftpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E7%AE%A1%E7%90%86/" rel="tag">hexo管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpd/" rel="tag">httpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pyinstaller/" rel="tag">pyinstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storage/" rel="tag">storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wss/" rel="tag">wss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%9B%98/" rel="tag">网盘</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Arm64/" style="font-size: 10px;">Arm64</a> <a href="/tags/Busybox/" style="font-size: 10px;">Busybox</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/Hello-World/" style="font-size: 16.67px;">Hello World</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/Pycharm/" style="font-size: 10px;">Pycharm</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Storage/" style="font-size: 10px;">Storage</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/edge/" style="font-size: 10px;">edge</a> <a href="/tags/for-test/" style="font-size: 10px;">for test</a> <a href="/tags/ftpd/" style="font-size: 10px;">ftpd</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo%E7%AE%A1%E7%90%86/" style="font-size: 10px;">hexo管理</a> <a href="/tags/httpd/" style="font-size: 10px;">httpd</a> <a href="/tags/kernel/" style="font-size: 10px;">kernel</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/pyinstaller/" style="font-size: 10px;">pyinstaller</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/storage/" style="font-size: 10px;">storage</a> <a href="/tags/websocket/" style="font-size: 13.33px;">websocket</a> <a href="/tags/wss/" style="font-size: 10px;">wss</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 10px;">网盘</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/22/ufs%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E7%96%91%E9%97%AE/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/11/%E5%AE%89%E5%8D%93%E4%BD%BF%E7%94%A8FUSE/">安卓使用FUSE</a>
          </li>
        
          <li>
            <a href="/2022/06/11/5W2H%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%A1%B9%E6%8A%80%E6%9C%AF/">如何学习一项技术</a>
          </li>
        
          <li>
            <a href="/2022/06/09/%E5%AE%89%E5%8D%93%E5%AD%98%E5%82%A8%E6%A0%88/">安卓存储栈</a>
          </li>
        
          <li>
            <a href="/2022/05/29/Linux-kernel-news/">Linux kernel news</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
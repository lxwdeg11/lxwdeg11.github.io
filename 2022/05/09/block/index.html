<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>block | 莫失莫忘的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] block层在内核中结构 内存管理与block：用户态page fault 脏页回写 swap out 都会产生IO到block层 cgroups in block三种情况没有支持cgroups：no scheduler, mq-deadline, and kyber   block io cgroup的作用：保护高优先级的IO（高优先级负载比低优先级负载优先获得IO）；通过什么方法？">
<meta property="og:type" content="article">
<meta property="og:title" content="block">
<meta property="og:url" content="http://example.com/2022/05/09/block/index.html">
<meta property="og:site_name" content="莫失莫忘的博客">
<meta property="og:description" content="[TOC] block层在内核中结构 内存管理与block：用户态page fault 脏页回写 swap out 都会产生IO到block层 cgroups in block三种情况没有支持cgroups：no scheduler, mq-deadline, and kyber   block io cgroup的作用：保护高优先级的IO（高优先级负载比低优先级负载优先获得IO）；通过什么方法？">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526202533888.png">
<meta property="og:image" content="https://facebookmicrosites.github.io/cgroup2/docs/assets/io_latency.png">
<meta property="og:image" content="d:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526203239408.png">
<meta property="article:published_time" content="2022-05-09T14:37:12.000Z">
<meta property="article:modified_time" content="2022-06-13T23:36:19.197Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="BLOCK IO">
<meta property="article:tag" content="LINUX KERNEL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526202533888.png">
  
    <link rel="alternate" href="/atom.xml" title="莫失莫忘的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">莫失莫忘的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/block/" class="article-date">
  <time datetime="2022-05-09T14:37:12.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      block
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="block层在内核中结构"><a href="#block层在内核中结构" class="headerlink" title="block层在内核中结构"></a>block层在内核中结构</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526202533888.png" alt="image-20220526202533888"></p>
<h1 id="内存管理与block："><a href="#内存管理与block：" class="headerlink" title="内存管理与block："></a>内存管理与block：</h1><p>用户态page fault</p>
<p>脏页回写</p>
<p>swap out</p>
<p>都会产生IO到block层</p>
<h1 id="cgroups-in-block"><a href="#cgroups-in-block" class="headerlink" title="cgroups in block"></a>cgroups in block</h1><p>三种情况没有支持cgroups：no scheduler, mq-deadline, and kyber  </p>
<h2 id="block-io-cgroup的作用："><a href="#block-io-cgroup的作用：" class="headerlink" title="block io cgroup的作用："></a>block io cgroup的作用：</h2><p>保护高优先级的IO（高优先级负载比低优先级负载优先获得IO）；通过什么方法？</p>
<p>限制cgroup的IOPS；</p>
<p>测量和检测cgroup的IO使用和IO压力（measure and monitor a cgroup’s IO use and <a target="_blank" rel="noopener" href="https://facebookmicrosites.github.io/cgroup2/docs/pressure-metrics.html">IO pressure</a>）</p>
<h2 id="cgroup-V2与V1的对比"><a href="#cgroup-V2与V1的对比" class="headerlink" title="cgroup V2与V1的对比"></a>cgroup V2与V1的对比</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>cgroup V1</td>
<td>只作用于direct IO（文件系统元数据的读写，缓冲读IO），没有控制缓冲写</td>
<td></td>
</tr>
<tr>
<td>cgroup V2</td>
<td>所有IO都能控制：buffered, filesystem metadata, swap, and direct IOs</td>
<td></td>
</tr>
</tbody></table>
<h2 id="cgroup-V2的接口文件"><a href="#cgroup-V2的接口文件" class="headerlink" title="cgroup V2的接口文件"></a>cgroup V2的接口文件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>io.latency</td>
<td>If the average completion latency is longer than the target set here, other processes are throttled to provide more IO, effectively prioritizing the job with the lowest <code>io.latency</code> setting.If the protected workload experiences average completion latency longer than its latency target value, <strong>the controller throttles any peers that have a more relaxed latency target than the protected workload</strong>.  <strong>平均完成时延，统计的时间窗口多大？                                                                                      <strong>The delta between the prioritized cgroup’s target and the targets of other cgroups is used to determine how hard the other cgroups are throttled: If a cgroup with <code>io.latency</code> set to <code>20ms</code> is prioritized, cgroups with latency targets <code>&lt;= 20ms</code> will never be throttled, while a cgroup with <code>50ms</code> will get throttled harder than a cgroup with a <code>30ms</code> target. <strong>这个限制力度是怎么控制的？通过控制cgroup的IO depth？</strong>                            <strong>只有兄弟cgroup才会互相影响。下面的图中，A B C会互相影响，D F会互相影响，G不影响任何其他人。</strong>                                                                                                                       <strong>配置策略</strong>：观察io.stat中你的工作负载的avg_lat的值来确定io.latency数值，比如可以配置1.2倍的io.stat avg_lat。 <code>io.latency</code>是</strong>work conserving</strong>，只有所有的cgroup都满足io.latency，就不会做任何限制。</td>
<td></td>
</tr>
<tr>
<td>io.pressure</td>
<td>这个啥意思？</td>
<td></td>
</tr>
<tr>
<td>io.stat</td>
<td>IO usage statistics.统计<strong>每个块设备</strong>（通过主设备号 次设备号区分）的读、写、擦除三类IO的扇区数和IO个数。</td>
<td></td>
</tr>
<tr>
<td>io.max</td>
<td>IO限制的指标。<strong>每个块设备</strong>分别计算，可以现在读、写IO的最大IOPS或者最大带宽。例如：Setting read limit at 2M BPS and write at 120 IOPS for 8:16：                            echo “8:16 rbps=2097152 wiops=120” &gt; io.max。通过写max取消限制：                 echo “8:16 wiops=max” &gt; io.max</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://facebookmicrosites.github.io/cgroup2/docs/assets/io_latency.png" alt="io latency diagram"></p>
<h2 id="io-latency的数值设置策略，针对ssd和hard-disk分别有设置策略："><a href="#io-latency的数值设置策略，针对ssd和hard-disk分别有设置策略：" class="headerlink" title="io.latency的数值设置策略，针对ssd和hard disk分别有设置策略："></a>io.latency的数值设置策略，针对ssd和hard disk分别有设置策略：</h2><blockquote>
<ol>
<li><strong>Setting <code>io.latency</code> higher (20-25%) than the usual expected latency.</strong> TThis provides a tighter protection guarantee for the workload. However, the tighter control can sometimes mean the system pays more in terms of IO overhead, which leads to lower system-wide IO utilization. A setting like this can be effective for systems with SSDs.</li>
<li><strong>Setting <code>io.latency</code> to several times higher than the usual expected latency, especially for hard disks.</strong> A hard disk’s usual uncontended completion latencies are between 7 and 20ms, but when contention occurs, the completion latency balloons quickly, easily reaching 10 times normal. Because the latency is so volatile, workloads running on hard disks are usually not sensitive to small swings in completion latency; things break down only in extreme conditions when latency jumps several times higher (which isn’t difficult to trigger). Effective protection can be achieved in cases like this by setting a relaxed target on the protected group (e.g., 50 or 75ms), and a higher setting for lower priority groups (e.g., an additional 25ms over the higher priority group). This way, the workload can have reasonable protection without significantly compromising hard disk utilization by triggering throttling when it’s not necessary.</li>
</ol>
</blockquote>
<h2 id="io-latency工作原理，限制的方法（一种是通过限制cgroup的queue-depth，最小限制到一次一个IO，另外一种是Artificial-delay-induction？）："><a href="#io-latency工作原理，限制的方法（一种是通过限制cgroup的queue-depth，最小限制到一次一个IO，另外一种是Artificial-delay-induction？）：" class="headerlink" title="io.latency工作原理，限制的方法（一种是通过限制cgroup的queue depth，最小限制到一次一个IO，另外一种是Artificial delay induction？）："></a>io.latency工作原理，限制的方法（一种是通过限制cgroup的queue depth，最小限制到一次一个IO，另外一种是<strong>Artificial delay induction？</strong>）：</h2><blockquote>
<ul>
<li><strong>Queue depth throttling</strong>—This is the number of outstanding IO’s a group is allowed to have. The controller will clamp down relatively quickly, starting at no limit and going all the way down to 1 IO at a time.</li>
<li><strong>Artificial delay induction</strong>—There are certain types of IO that can’t be throttled without possibly affecting higher priority groups adversely. This includes swapping and metadata IO. These types of IO are allowed to occur normally, but they are “charged” to the originating group.</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://facebookmicrosites.github.io/cgroup2/docs/io-controller.html#fbtax2-io-controller-configuration">IO Controller · cgroup2 (facebookmicrosites.github.io)</a> 这个还没看？</p>
<h1 id="不同IO-control机制对比："><a href="#不同IO-control机制对比：" class="headerlink" title="不同IO control机制对比："></a>不同IO control机制对比：</h1><p><img src="D:%5Cappdata%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526203239408.png" alt="image-20220526203239408"></p>
<h1 id="biovecs"><a href="#biovecs" class="headerlink" title="biovecs"></a>biovecs</h1><p>bio提交后biovecs就不能修改了，随着IO完成而修改的是struct bvec_iter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> &#123;</span></span><br><span class="line">	<span class="type">sector_t</span>		bi_sector;	<span class="comment">/* device address in 512 byte</span></span><br><span class="line"><span class="comment">						   sectors */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		bi_size;	<span class="comment">/* residual I/O count */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		bi_idx;		<span class="comment">/* current index into bvl_vec */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>            bi_bvec_done;	<span class="comment">/* number of bytes completed in</span></span><br><span class="line"><span class="comment">						   current bvec */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>驱动代码不应该直接使用biovecs，而应该用bio_iovec() and bio_iter_iovec()</p>
<h3 id="bio-for-each-segment改为需要一个bvec-iter参数，而不是整数参数"><a href="#bio-for-each-segment改为需要一个bvec-iter参数，而不是整数参数" class="headerlink" title="bio_for_each_segment改为需要一个bvec_iter参数，而不是整数参数"></a>bio_for_each_segment改为需要一个bvec_iter参数，而不是整数参数</h3><p>通过bio_advance_iter函数，递增bvec_iter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bio_advance</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">unsigned</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bio_integrity(bio))</span><br><span class="line">		bio_integrity_advance(bio, bytes);</span><br><span class="line"></span><br><span class="line">	bio_advance_iter(bio, &amp;bio-&gt;bi_iter, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个更低层的，bvec_iter_advance，使用biovec指针作为参数，而不是bio指针：</p>
<h3 id="用于block的integrity-code"><a href="#用于block的integrity-code" class="headerlink" title="用于block的integrity code"></a>用于block的integrity code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bio_vec &#123;</span><br><span class="line">	struct page	*bv_page;</span><br><span class="line">	unsigned int	bv_len;//可能跨页面，例如长度是8K</span><br><span class="line">	unsigned int	bv_offset; //可能跨页面，例如offset是4K + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>有一个迭代器，而让真正的biovecs保存不变，有很多好处。</p>
<h3 id="一次迭代一个页："><a href="#一次迭代一个页：" class="headerlink" title="一次迭代一个页："></a>一次迭代一个页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio_for_each_segment()</span><br><span class="line">bio_for_each_segment_all()</span><br></pre></td></tr></table></figure>

<h3 id="一次迭代多个页："><a href="#一次迭代多个页：" class="headerlink" title="一次迭代多个页："></a>一次迭代多个页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bio_for_each_bvec()</span><br><span class="line">bio_for_each_bvec_all()</span><br><span class="line">rq_for_each_bvec()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">introduce <span class="title function_">bio_for_each_bvec</span><span class="params">()</span> to iterate over multipage bvec <span class="keyword">for</span> splitting</span><br><span class="line">	bio and mapping sg</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">introduce bio_for_each_bvec() to iterate over multipage bvec for splitting</span><br><span class="line">	bio and mapping sg</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keep current bio_for_each_segment*() to itereate over singlepage bvec</span><br></pre></td></tr></table></figure>



<h1 id="block层的work"><a href="#block层的work" class="headerlink" title="block层的work"></a>block层的work</h1><h2 id="对应的work-function：blk-mq-run-work-fn"><a href="#对应的work-function：blk-mq-run-work-fn" class="headerlink" title="对应的work function：blk_mq_run_work_fn"></a>对应的work function：blk_mq_run_work_fn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_mq_run_work_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *<span class="title">hctx</span>;</span></span><br><span class="line"></span><br><span class="line">	hctx = container_of(work, <span class="keyword">struct</span> blk_mq_hw_ctx, run_work.work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are stopped, don&#x27;t run the queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blk_mq_hctx_stopped(hctx))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__blk_mq_run_hw_queue(hctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="work初始化"><a href="#work初始化" class="headerlink" title="work初始化"></a>work初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_DELAYED_WORK(&amp;hctx-&gt;run_work, blk_mq_run_work_fn);</span><br></pre></td></tr></table></figure>

<p>每个hctx都有一个自己的run_work，所有这些work，共用一个workqueue：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Controlling structure to kblockd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">kblockd_workqueue</span>;</span></span><br></pre></td></tr></table></figure>

<p><a href="#workqueue%E4%BC%98%E5%8C%96">workqueue优化</a></p>
<h2 id="block的worker运行的cpu："><a href="#block的worker运行的cpu：" class="headerlink" title="block的worker运行的cpu："></a>block的worker运行的cpu：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;d be great if the workqueue API had a way to pass</span></span><br><span class="line"><span class="comment"> * in a mask and had some smarts for more clever placement.</span></span><br><span class="line"><span class="comment"> * For now we just round-robin here, switching for every</span></span><br><span class="line"><span class="comment"> * BLK_MQ_CPU_WORK_BATCH queued items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">blk_mq_hctx_next_cpu</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> tried = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> next_cpu = hctx-&gt;next_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hctx-&gt;<span class="built_in">queue</span>-&gt;nr_hw_queues == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> WORK_CPU_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (--hctx-&gt;next_cpu_batch &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">select_cpu:</span><br><span class="line">		next_cpu = cpumask_next_and(next_cpu, hctx-&gt;cpumask,</span><br><span class="line">				cpu_online_mask);</span><br><span class="line">		<span class="keyword">if</span> (next_cpu &gt;= nr_cpu_ids)</span><br><span class="line">			next_cpu = blk_mq_first_mapped_cpu(hctx);</span><br><span class="line">		hctx-&gt;next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do unbound schedule if we can&#x27;t find a online CPU for this hctx,</span></span><br><span class="line"><span class="comment">	 * and it should only happen in the path of handling CPU DEAD.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_online(next_cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!tried) &#123;</span><br><span class="line">			tried = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">goto</span> select_cpu;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make sure to re-select CPU next time once after CPUs</span></span><br><span class="line"><span class="comment">		 * in hctx-&gt;cpumask become online again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		hctx-&gt;next_cpu = next_cpu;</span><br><span class="line">		hctx-&gt;next_cpu_batch = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> WORK_CPU_UNBOUND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hctx-&gt;next_cpu = next_cpu;</span><br><span class="line">	<span class="keyword">return</span> next_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kblockd_mod_delayed_work_on(blk_mq_hctx_next_cpu(hctx), &amp;hctx-&gt;run_work,</span><br><span class="line">				    msecs_to_jiffies(msecs));</span><br></pre></td></tr></table></figure>

<p>如果queue的硬件队列只有一个，那这个worker运行在WORK_CPU_UNBOUND上，也就是不绑定特定的cpu。</p>
<p>否则，一个cpu上运行<strong>BLK_MQ_CPU_WORK_BATCH</strong>次数后，就换下一个cpu（round robin策略）。</p>
<p>当然，可供选择的cpu的范围：同时在<strong>hctx-&gt;cpumask</strong>和cpu_online_mask里面的cpu。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next_cpu = cpumask_next_and(next_cpu, hctx-&gt;cpumask,</span><br><span class="line">				cpu_online_mask);</span><br></pre></td></tr></table></figure>



<p>hctx-&gt;cpu_mask在blk_mq_map_swqueue函数里面设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpumask_set_cpu(i, hctx-&gt;cpumask)</span><br></pre></td></tr></table></figure>

<h2 id="什么情况运行work？"><a href="#什么情况运行work？" class="headerlink" title="什么情况运行work？"></a>什么情况运行work？</h2><h2 id="什么情况停止work？"><a href="#什么情况停止work？" class="headerlink" title="什么情况停止work？"></a>什么情况停止work？</h2><h1 id="block-passthrough-req流程"><a href="#block-passthrough-req流程" class="headerlink" title="block passthrough req流程"></a>block passthrough req流程</h1><h3 id="end-io流程"><a href="#end-io流程" class="headerlink" title="end_io流程"></a>end_io流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rq-&gt;end_io赋值为了blk_end_sync_rq</span><br><span class="line"></span><br><span class="line"><span class="title function_">DECLARE_COMPLETION_ONSTACK</span><span class="params">(wait)</span>;</span><br><span class="line">rq-&gt;end_io_data = &amp;wait;</span><br><span class="line"></span><br><span class="line">__blk_mq_end_request里面：</span><br><span class="line"><span class="keyword">if</span> (rq-&gt;end_io) &#123;</span><br><span class="line">		rq_qos_done(rq-&gt;q, rq);</span><br><span class="line">		rq-&gt;end_io(rq, error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		blk_mq_free_request(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * blk_end_sync_rq - executes a completion event on a request</span></span><br><span class="line"><span class="comment"> * @rq: request to complete</span></span><br><span class="line"><span class="comment"> * @error: end I/O status of the request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_end_sync_rq</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">blk_status_t</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">waiting</span> =</span> rq-&gt;end_io_data;</span><br><span class="line"></span><br><span class="line">	rq-&gt;end_io_data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * complete last, if this is a stack request the process (and thus</span></span><br><span class="line"><span class="comment">	 * the rq pointer) could be invalid right after this complete()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	complete(waiting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="block层调度器ops"><a href="#block层调度器ops" class="headerlink" title="block层调度器ops"></a>block层调度器ops</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elevator_mq_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*init_sched)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> elevator_type *);</span><br><span class="line">	<span class="type">void</span> (*exit_sched)(<span class="keyword">struct</span> elevator_queue *);</span><br><span class="line">	<span class="type">int</span> (*init_hctx)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*exit_hctx)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*depth_updated)(<span class="keyword">struct</span> blk_mq_hw_ctx *);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> (*allow_merge)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">struct</span> bio *);</span><br><span class="line">	<span class="type">bool</span> (*bio_merge)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> bio *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*request_merge)(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request **, <span class="keyword">struct</span> bio *);</span><br><span class="line">	<span class="type">void</span> (*request_merged)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">enum</span> elv_merge);</span><br><span class="line">	<span class="type">void</span> (*requests_merged)(<span class="keyword">struct</span> request_queue *, <span class="keyword">struct</span> request *, <span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*limit_depth)(<span class="type">unsigned</span> <span class="type">int</span>, <span class="keyword">struct</span> blk_mq_alloc_data *);</span><br><span class="line">	<span class="type">void</span> (*prepare_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*finish_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="type">void</span> (*insert_requests)(<span class="keyword">struct</span> blk_mq_hw_ctx *, <span class="keyword">struct</span> list_head *, <span class="type">bool</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">dispatch_request</span>)(<span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *);</span></span><br><span class="line">	<span class="type">bool</span> (*has_work)(<span class="keyword">struct</span> blk_mq_hw_ctx *);</span><br><span class="line">	<span class="type">void</span> (*completed_request)(<span class="keyword">struct</span> request *, u64);</span><br><span class="line">	<span class="type">void</span> (*requeue_request)(<span class="keyword">struct</span> request *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">former_request</span>)(<span class="keyword">struct</span> <span class="title">request_queue</span> *, <span class="keyword">struct</span> <span class="title">request</span> *);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *(*<span class="title">next_request</span>)(<span class="keyword">struct</span> <span class="title">request_queue</span> *, <span class="keyword">struct</span> <span class="title">request</span> *);</span></span><br><span class="line">	<span class="type">void</span> (*init_icq)(<span class="keyword">struct</span> io_cq *);</span><br><span class="line">	<span class="type">void</span> (*exit_icq)(<span class="keyword">struct</span> io_cq *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);</p>
<p>bio转化为request之前，尝试与现有的request合并。</p>
<p>int (*request_merge)(struct request_queue *q, struct request **, struct bio *);</p>
<p>把BIO合并到现有的request中，如果合并成功，则把request指针存到struct request **中。</p>
<p>void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);</p>
<p>上面BIO合并到一个request后，如果这个新的request可能跟前面或者后面的request可以合并（见attempt_front_merge和attempt_back_merge），则合并后的处理函数为  request_merged。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct request *attempt_back_merge(struct request_queue *q,</span><br><span class="line">		struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request *next = elv_latter_request(q, rq);</span><br><span class="line"></span><br><span class="line">	if (next)</span><br><span class="line">		return attempt_merge(q, rq, next);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct request *attempt_front_merge(struct request_queue *q,</span><br><span class="line">		struct request *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct request *prev = elv_former_request(q, rq);</span><br><span class="line"></span><br><span class="line">	if (prev)</span><br><span class="line">		return attempt_merge(q, prev, rq);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>void (*requests_merged)(struct request_queue *, struct request *, struct request *);</p>
<p>request插入到调度器队列里面时，尝试遍历队列里request，找到能合并的request。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Callback function that is invoked after @next has been merged into @req.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dd_merged_requests</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request *req,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> request *next)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例子一：</span><br><span class="line">   dd_insert_request</span><br><span class="line">	blk_mq_sched_try_insert_merge</span><br><span class="line">		elv_attempt_insert_merge</span><br><span class="line">			blk_attempt_req_merge</span><br><span class="line">				attempt_merge</span><br><span class="line">					elv_merge_requests</span><br><span class="line">例子二：</span><br><span class="line">  dd_bio_merge</span><br><span class="line">    blk_mq_sched_try_merge</span><br><span class="line">    	elv_merge后可能bio_attempt_back_merge后可能二次合并attempt_back_merge</span><br><span class="line">    		attempt_merge</span><br><span class="line">    			elv_merge_requests</span><br><span class="line"><span class="type">void</span> <span class="title function_">elv_merge_requests</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> request *rq,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> request *next)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">e</span> =</span> q-&gt;elevator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;type-&gt;ops.requests_merged)</span><br><span class="line">		e-&gt;type-&gt;ops.requests_merged(q, rq, next);</span><br><span class="line"></span><br><span class="line">	elv_rqhash_reposition(q, rq);</span><br><span class="line">	q-&gt;last_merge = rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以合并，则作用是：next合并到req后，调度器需要做的处理；</p>
<p>void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);</p>
<p>调用地方：</p>
<p>static struct request *__blk_mq_alloc_request(struct blk_mq_alloc_data *data)里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Flush/passthrough requests are special and go directly to the</span></span><br><span class="line"><span class="comment">		 * dispatch list. Don&#x27;t include reserved tags in the</span></span><br><span class="line"><span class="comment">		 * limiting, as it isn&#x27;t useful.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!op_is_flush(data-&gt;cmd_flags) &amp;&amp;</span><br><span class="line">		    !blk_op_is_passthrough(data-&gt;cmd_flags) &amp;&amp;</span><br><span class="line">		    e-&gt;type-&gt;ops.limit_depth &amp;&amp;</span><br><span class="line">		    !(data-&gt;flags &amp; BLK_MQ_REQ_RESERVED))</span><br><span class="line">			e-&gt;type-&gt;ops.limit_depth(data-&gt;cmd_flags, data);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>limit_depth函数里面会设置data-&gt;shallow_depth，req获取tag时候会根据data-&gt;shallow_depth限制深度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __blk_mq_get_tag(<span class="keyword">struct</span> blk_mq_alloc_data *data,</span><br><span class="line">			    <span class="keyword">struct</span> sbitmap_queue *bt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!data-&gt;q-&gt;elevator &amp;&amp; !(data-&gt;flags &amp; BLK_MQ_REQ_RESERVED) &amp;&amp;</span><br><span class="line">			!hctx_may_queue(data-&gt;hctx, bt))</span><br><span class="line">		<span class="keyword">return</span> BLK_MQ_NO_TAG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;shallow_depth)</span><br><span class="line">		<span class="keyword">return</span> __sbitmap_queue_get_shallow(bt, data-&gt;shallow_depth);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> __sbitmap_queue_get(bt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">blk_mq_sched_try_merge</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> nr_segs, <span class="keyword">struct</span> request **merged_request)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (elv_merge(q, &amp;rq, bio)) &#123;<span class="comment">//queue里找到bio能合并到的rq，从e-&gt;hash哈希表（或者q-&gt;last_merge）里选择rq，或者通过e-&gt;type-&gt;ops.request_merge选择bio能合并到的req</span></span><br><span class="line">    <span class="comment">//e-&gt;hash是以req的结束扇区地址为哈希值     </span></span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_BACK_MERGE:</span><br><span class="line">		<span class="keyword">if</span> (!blk_mq_sched_allow_merge(q, rq, bio))<span class="comment">//是否允许合并</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (bio_attempt_back_merge(rq, bio, nr_segs) != BIO_MERGE_OK)<span class="comment">//执行bio合并到rq动作</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		*merged_request = attempt_back_merge(q, rq);<span class="comment">//bio合并到rq后，rq尝试与后面的一个请求rq合并，attempt_back_merge调用attempt_merge</span></span><br><span class="line">		<span class="keyword">if</span> (!*merged_request)</span><br><span class="line">			elv_merged_request(q, rq, ELEVATOR_BACK_MERGE);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_FRONT_MERGE:</span><br><span class="line">		<span class="keyword">if</span> (!blk_mq_sched_allow_merge(q, rq, bio))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (bio_attempt_front_merge(rq, bio, nr_segs) != BIO_MERGE_OK)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		*merged_request = attempt_front_merge(q, rq);<span class="comment">//attempt_front_merge调用attempt_merge</span></span><br><span class="line">		<span class="keyword">if</span> (!*merged_request)</span><br><span class="line">			elv_merged_request(q, rq, ELEVATOR_FRONT_MERGE);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">case</span> ELEVATOR_DISCARD_MERGE:</span><br><span class="line">		<span class="keyword">return</span> bio_attempt_discard_merge(q, rq, bio) == BIO_MERGE_OK;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bio-merge与request-merge区别？"><a href="#bio-merge与request-merge区别？" class="headerlink" title="bio_merge与request_merge区别？"></a>bio_merge与request_merge区别？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_type</span> *<span class="title">type</span>;</span></span><br><span class="line">	<span class="type">void</span> *elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">sysfs_lock</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> registered:<span class="number">1</span>;</span><br><span class="line">	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>elevator_queue的hash：</p>
<p>请求加入hash队列时候是以请求的结束地址加入的。</p>
<h1 id="哪些种类IO有rq-gt-end-io指针？"><a href="#哪些种类IO有rq-gt-end-io指针？" class="headerlink" title="哪些种类IO有rq-&gt;end_io指针？"></a>哪些种类IO有rq-&gt;end_io指针？</h1><h1 id="可能优化点："><a href="#可能优化点：" class="headerlink" title="可能优化点："></a>可能优化点：</h1><h2 id="workqueue优化"><a href="#workqueue优化" class="headerlink" title="workqueue优化"></a>workqueue优化</h2><h3 id="采用多个workqueue"><a href="#采用多个workqueue" class="headerlink" title="采用多个workqueue"></a>采用多个workqueue</h3><h4 id="不同优先级的IO，采用不同优先级的workqueue？"><a href="#不同优先级的IO，采用不同优先级的workqueue？" class="headerlink" title="不同优先级的IO，采用不同优先级的workqueue？"></a>不同优先级的IO，采用不同优先级的workqueue？</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/block/" data-id="cl2yty06q0001r8vkaenx88u6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BLOCK-IO/" rel="tag">BLOCK IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LINUX-KERNEL/" rel="tag">LINUX KERNEL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/09/hexo/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          登录edge浏览器，报错0x80190001解决方法
        
      </div>
    </a>
  
  
    <a href="/2022/05/09/test/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">test</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/">安卓开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arm64/" rel="tag">Arm64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLOCK-IO/" rel="tag">BLOCK IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Busybox/" rel="tag">Busybox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hello-World/" rel="tag">Hello World</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LINUX-KERNEL/" rel="tag">LINUX KERNEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage/" rel="tag">Storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/" rel="tag">adb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edge/" rel="tag">edge</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for-test/" rel="tag">for test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftpd/" rel="tag">ftpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E7%AE%A1%E7%90%86/" rel="tag">hexo管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpd/" rel="tag">httpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pyinstaller/" rel="tag">pyinstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storage/" rel="tag">storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wss/" rel="tag">wss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%9B%98/" rel="tag">网盘</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Arm64/" style="font-size: 10px;">Arm64</a> <a href="/tags/BLOCK-IO/" style="font-size: 10px;">BLOCK IO</a> <a href="/tags/Busybox/" style="font-size: 10px;">Busybox</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/Hello-World/" style="font-size: 16.67px;">Hello World</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/LINUX-KERNEL/" style="font-size: 10px;">LINUX KERNEL</a> <a href="/tags/Pycharm/" style="font-size: 10px;">Pycharm</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Storage/" style="font-size: 10px;">Storage</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/edge/" style="font-size: 10px;">edge</a> <a href="/tags/for-test/" style="font-size: 10px;">for test</a> <a href="/tags/ftpd/" style="font-size: 10px;">ftpd</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo%E7%AE%A1%E7%90%86/" style="font-size: 10px;">hexo管理</a> <a href="/tags/httpd/" style="font-size: 10px;">httpd</a> <a href="/tags/kernel/" style="font-size: 10px;">kernel</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/pyinstaller/" style="font-size: 10px;">pyinstaller</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/storage/" style="font-size: 10px;">storage</a> <a href="/tags/websocket/" style="font-size: 13.33px;">websocket</a> <a href="/tags/wss/" style="font-size: 10px;">wss</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 10px;">网盘</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/11/%E5%AE%89%E5%8D%93%E4%BD%BF%E7%94%A8FUSE/">安卓使用FUSE</a>
          </li>
        
          <li>
            <a href="/2022/06/11/5W2H%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%A1%B9%E6%8A%80%E6%9C%AF/">如何学习一项技术</a>
          </li>
        
          <li>
            <a href="/2022/06/09/%E5%AE%89%E5%8D%93%E5%AD%98%E5%82%A8%E6%A0%88/">安卓存储栈</a>
          </li>
        
          <li>
            <a href="/2022/05/29/Linux-kernel-news/">Linux kernel news</a>
          </li>
        
          <li>
            <a href="/2022/05/27/python%E5%BB%BA%E7%AB%8Bsocket-server-websocket-server/">python建立socket server(websocket server)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>